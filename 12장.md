## 채팅 시스템 설계

### 읽기 전 간단하게 설계해보기
+ 채팅 메시지는 실시간으로 전달
    - 그룹 채팅
+ 이미지, 동영상 전송 가능
+ 채팅 이력 저장

### 놓친 부분
+ 처리해야 하는 트래픽 규모 설정
+ 푸시 알림
+ 어떤 통신 프로토콜을 사용할지
    - HTTP, keep alive 헤더 사용

### 채팅 시스템 작업 흐름
+ 클라이언트로부터 메시지 수신
+ 메시지 수신자 결정 및 전달
+ 수신자가 접속 상태가 아닌 경우, 접속할 때까지 해당 메시지 보관

### 메시지 수신 프로토콜
HTTP는 클라이언트가 요청해야만 서버가 응답하는 구조  
우리가 필요로 하는 실시간 채팅 메시지에는 올바르지 않다  

+ 폴링
    - 클라이언트가 주기적으로 서버에 새 메시지가 있는지 확인하는 방법
    - 장점
        + HTTP 인프라를 그대로 사용하기 떄문에 구현이 간단
    - 단점
        + 불필요한 요청이 많음 (새 데이터가 없어도 계속 확인)
        + 서버 부하가 크다 (1000명이 5초마다 요청하면 초당 200개 요청)
        + 실시간성이 떨어진다 (폴링 주기만큼 지연이 발생)
+ 롱 폴링
    - 폴링의 비효율적인 단점을 보완한 기법
    - 동작방식
        + 클라이언트가 요청을 보냄
        + 서버는 연결을 유지한 채 대기
        + 새 데이터가 생기거나 타임아웃되면 응답
        + 클라이언트가 응답을 받으면 다시 요청
    - 장점
        + 폴링보다 훨씬 적은 서버의 부담
        + 폴링보다 실시간성이 좋다
    - 단점
        + 여전히 HTTP 오버헤드 존재
        + 서버가 많은 연결을 동시에 유지해야 함
        + 프록시나 방화벽에서 타임아웃 문제가 발생할 수 있음
+ 웹소켓
    - HTTP로 시작하지만 핸드셰이크 후 TCP 연결로 업그레이드되는 연결방식
    - 동작방식
        + HTTP 연결로 시작
        + Upgrade 헤더로 WebSocket으로 전환 요청
        + 핸드셰이크 성공하면 WebSocket 연결 수립
        + 양방향으로 데이터 송수신
    - 장점
        + 실시간 양방향 통신 가능
        + 낮은 오버헤드 (연결 유지 중 헤더 불필요)
        + 서버에서 클라이언트로 푸시 가능
    - 단점
        + 상태를 유지해야 해서 스케일링이 어려움
            - 웹소켓은 stateful이라 서버가 추가되면 각 서버를 동기화할 메시지 큐가 필요

### 저장소
채팅 시스템이 다루는 데이터는 보통 두가지  
첫번째는 사용자 프로필, 설정, 친구 목록과 같은 일반적인 데이터  
이런 데이터는 안정성을 보장하는 관계형 데이터베이스에 보관한다  

두번째는 채팅 시스템의 고유한 데이터로 `채팅이력`  
채팅 이력 데이터의 양은 엄청나다 그리고 방대한 채팅 데이터 중 빈번하게 사용되는 것은 최근에 주고 받은 메시지다  
사용자는 대체적으로 최근 메시지만 확인하지만 검색 기능을 이용하거나 멘션된 메시지를 확인할 수도 있다  

이런 점을 고려하면 채팅 이력은 키-값 저장소에 저장하는 편이 추천된다  

+ 키-값 저장소는 수평적 규모확장이 쉽다
+ 키-값 저장소는 데이터 접근 지연시간(레이턴시)가 낮다
+ 관계형 데이터베이스는 롱 테일에 해당하는 부분을 잘 처리하지 못한다  

### 데이터 모델
채팅 시스템에서 메시지 ID는 매우 중요하다  

+ message_id는 항상 고유한 값이어야 한다
+ message_id는 정렬 가능해야 하며 시간 순서와도 일치해야 한다  

관계형 데이터베이스는 PK로 위의 조건을 충족시킬 수 있지만 NoSQL은 PK가 없다  
따라서 스노우플레이크나 지역적 순서 번호 생성기를 사용하는 방법이 있다  

+ 스노우플레이크
    - 64bit 정수 기반의 분산 ID 생성 알고리즘
    - 스노우플레이크의 구조
        ```
        ┌─────────────┬──────────┬──────────┬────────────┐
        │   41 bit    │  10 bit  │  12 bit  │            │
        │  Timestamp  │ Machine  │ Sequence │   64 bit   │
        │             │    ID    │  Number  │     ID     │
        └─────────────┴──────────┴──────────┴────────────┘
            ↑            ↑          ↑
        시간 순서    서버 구분   동시성 처리
        ```
        + 1bit : 부호 비트 (0으로 고정, 사용하지 않음)
        + 40bit : 타임스탬프 (밀리초 단위)
        + 10bit : 머신 ID (최대 1024대의 서버 구분)
        + 12bit : 시퀀스 번호 (같은 밀리초 내 최대 4096개의 ID 생성)

        ```java
        public class SnowflakeIdGenerator {
            private final long machineId;
            private long sequence = 0L;
            private long lastTimestamp = -1L;
            
            public synchronized long nextId() {
                long timestamp = System.currentTimeMillis();
                
                // 같은 밀리초 내 요청
                if (timestamp == lastTimestamp) {
                    sequence = (sequence + 1) & 4095; // 12bit 마스크
                    if (sequence == 0) {
                        // 시퀀스 초과, 다음 밀리초 대기
                        timestamp = waitNextMillis();
                    }
                } else {
                    sequence = 0L; // 새로운 밀리초, 시퀀스 리셋
                }
                
                lastTimestamp = timestamp;
                
                // 비트 조합
                return (timestamp << 22) | (machineId << 12) | sequence;
            }
        }
        ``` 
    - 장점
        + 시간 정렬 가능 (ID가 시간순이라 정렬 필드가 필요 X)
        + 정수형이라 DB 인덱싱에 효과적

![12장 화이트보드 설계](./images/12장%20설계%20이미지.png)