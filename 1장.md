## 사용자 수에 따른 규모 확장성

### 단일서버
+ 사용자 요청이 처리되는 과정
    - 사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속
    - 접속을 위해서는 도메인 이름을 도메인 이름 서비스(DNS)에 질의하여 IP로 변환하는 과정이 필요
    - 변환된 IP 주소로 HTTP 요청을 전달
    - 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환

### 데이터베이스
사용자가 늘어나면 하나의 서버에서 모든 요청을 처리하기 어렵다  
그래서 서버를 하나는 웹/모바일 트래픽 처리 용도, 다른 하나는 데이터베이스용으로 나눈다  
이렇게 분리하면 서버를 각각 독립적으로 확장해 나갈 수 있다

+ 어떤 데이터베이스를 사용할 것인가
    - 관계형 데이터베이스 (RDBMS)
        + MySQL, Oracle, PostgreSQL 등이 존재
        + 자료를 테이블과 열, 칼럼으로 표현
        + 여러 테이블에 저장된 자료를 join으로 합쳐서 가져올 수 있다
    - 비-관계형 데이터베이스 (NoSQL)
        + HBase, Amazon DynamoD, Cassandra 등이 존재
        + 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나눌 수 있다
        + 비관계형 데이터베이스는 Join 연산을 지원하지 않는다
    - 아래와 같은 경우, 비-관계형 데이터베이스가 더 바람직한 선택일 수 있다
        + 아주 낮은 응답시간이 요구됨(latency)
        + 다루는 데이터가 비정형 데이터
        + JSON, YAML, XML 등을 직렬화하거나 역직렬화 해야함
        + 아주 많은 양의 데이터를 저장할 필요가 있음

### 수직적 규모 확장 vs 수평적 규모 확장
+ 수직적 규모 확장
    - 스케일 업
    - 서버에 고사양 자원(CPU, RAM)을 추가하는 행위
    - 서버로 유입되는 트래픽의 양이 적을때는 수직적 확장이 유리
    - 단점
        + 수직적 규모 확장에서는 한계가 있다, 한대의 서버에 CPU나 메모리를 무한으로 증설할 수 없으므로
        + 수직적 규모 확장은 장애에 대한 자동복구나 다중화 방안이 없다, 서버에 장애가 발생하면 웹/앱이 모두 중단됨  

이러한 수직적 규모 확장의 단점을 해소하기 위해 부하 분산기 또는 로드밸런서를 도입해서 처리한다  

+ 로드밸런서가 부하를 분산하는 방법
    - 사용자가 로드밸런서의 공개 IP로 접근한다
        + 웹서버는 클라이언트의 요청을 직접 처리하지 않는다
        + 로드밸런서와 웹서버는 사설 IP로 연결되어 외부에서 웹서버로 직접 접근이 불가능하다
    - 부하분산 집합에 하나의 웹서버를 추가하면 페일오버 문제는 해소되고 웹서버의 가용성은 향상된다

+ 데이터베이스 다중화
    - 마스터-슬레이브 구조
        + 쓰기 연산은 마스터에서만 지원
        + 슬레이브는 마스터로부터 데이터 사본을 전달받고 읽기 연산만 지원한다

### 종합
위에서 언급된 로드밸런서와 데이터베이스 다중화를 고려한 설계안을 확인해보자  
1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다
2. 사용자는 공개 IP 주소를 사용하여 로드밸런서에 접속한다
3. HTTP 요청은 로드밸런서를 통해 여러 대의 서버 중 하나로 전달된다
4. 웹 서버는 사용자의 데이터를 슬레이브 서버에서 읽는다
5. 웹 서버는 데이터 변경 연산은 마스터 서버로 전달한다 (데이터 추가, 삭제, 갱신 등)

### 캐시
캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 저장하고 다음 요청이 보다 빠르게 처리되도록 지원하는 저장소  
웹페이지를 새로고침할때마다 데이터를 가져오기 위해 DB IO가 발생하는데, 캐시는 이런 문제를 완화할 수 있다  

+ 캐시 계층
    - 데이터가 잠시 보관되는 곳, 데이터베이스보다 훨씬 빠르다
    - 별도의 캐시 계층덕분에 데이터베이스의 부하를 줄일 수 있다
    - 캐시 전략
        + Cache-Aside (Lazy Loading)
            - 애플리케이션이 데이터를 읽을 때, 캐시를 먼저 확인
            - 캐시에 있으면 (Hit) -> 바로 반환
            - 캐시에 없으면 (Miss) -> DB 조회 후 캐시에 저장하고 반환
            - 데이터 쓰기는 DB에만 하고 캐시는 무효화하거나 업데이트
            - 장점
                + 실제로 요청하는 데이터만 캐싱되어 메모리가 효율적
                + 캐시 장애가 발생해도 DB로 서비스 가능 (fallback)
            - 단점
                + 최초 요청은 항상 느림 (Cache Miss)
                + 쓰기 작업시 캐시-DB 불일치 가능성
        + Read-Through
            - 캐시가 DB 앞단에 위치하여 모든 읽기를 담당
            - 애플리케이션은 항상 캐시에 요청
            - 캐시에 데이터가 없으면 캐시 시스템이 자동으로 DB 조회후 저장
            - 캐시가 DB 접근 로직을 캡슐화
            - 장점
                + 애플리케이션 코드가 단순해짐
                + 캐시 로직과 비즈니스 로직 분리
            - 단점
                + 최초 요청은 느림
                + 캐시 시스템이 복잡
        + Write-Throude
            - 쓰기 작업시 캐시와 DB를 동시에 업데이트
            - 데이터를 캐시에 먼저 쓰고 DB에도 저장
            - 캐시와 DB가 항상 동기화 유지
            - 장점
                + 데이터 일관성 보장 (캐시-DB 불일치 최소화)
                + 읽기 성능 우수
            - 단점
                + 쓰기 성능 저하 (캐시+DB 두번 작업)
                + 사용하지 않는 데이터도 캐싱될 수 있음

+ 캐시 사용시 유의할 점
    - 데이터 갱신은 자주 일어나지 않지만 참조는 빈번할 때
    - 캐시는 데이터를 휘발성 메모리에 저장하므로 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않음
    - 캐시에 보관된 데이터의 만료시점 정책
        + 만료 기한이 짧으면 데이터베이스 IO가 빈번해진다
        + 만료 기한이 너무 길면 DB와 캐시의 데이터 불일치 가능성이 커진다
    - 데이터 일관성의 유지
        + 데이터 저장소의 원본과 캐시의 사본이 같은지 여부
        + 저장소에 데이터를 저장하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션이 아닌 경우, 일관성이 깨질 수 있다
    - 장애대처
        - 캐시 서버를 한대만 두는 경우, 단일 장애 지점이 될 가능성이 커진다
    - 캐시 메모리가 작으면 데이터가 자주 캐시에서 밀려나는 경우(eviction)이 생긴다
        + LRU (Least Recently Used)
            - 가장 오래 사용하지 않은 데이터를 제거(시간순)
            - 장점
                + 구현이 비교적 간단
                + 시간 지역성 활용
                + 대부분의 상황에서 가장 무난한 성능
            - 단점
                + 사용빈도는 낮지만 중요한 데이터가 제거될 수 있음
                + 순차 스캔시 모든 캐시가 교체될 가능성 존재
        + LFU (Least Frequently Used)
            - 사용 빈도가 가장 낮은 데이터를 제거(사용횟수순)
            - 장점
                + 자주 사용되는 데이터 보호
                + 일시적인 접근 패턴에 덜 민감
            - 단점
                + 과거 빈도에 의존 (최근 인기 급상승 데이터 밀릴 수 있음)
        + FIFO (First In First Out)
            - 가장 먼저 들어온 데이터를 먼저 제거
            - 장점
                + 예측 가능한 동작
            - 단점
                + 자주 사용되는 데이터도 오래되면 제거됨
        + TTL (Time To Live)
            - 만료 시간 미리 설정

### 콘텐츠 전송 네트워크 (CDN)
CDN은 정적 콘텐츠를 전송하는데 사용되는 지리적으로 분산된 서버의 네트워크다  
이미지, 비디오, CSS, JS 파일 등을 캐시한다  

+ CDN이 동작하는 과정
    - 사용자 A가 이미지 URL을 이용해 이미지에 접근한다, 이미지 URL은 CDN 서비스 사업자가 제공
    - CDN 서버의 캐시에 이미지가 없는 경우, 원본 서버에 요청하여 파일을 가져온다
    - 원본 서버가 파일을 CDN 서버에 반환하고 응답 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시되는지 TTL 값이 설정된다
    - CDN 서버는 파일을 캐시하고 사용자에게 반환한다, 이미지는 설정된 TTL만큼 캐시된다
    - 사용자 B가 같은 이미지에 대한 요청을 CDN에 전송
    - 만료되지 않은 콘텐츠에 대한 요청은 캐시를 통해 처리된다

+ CDN 사용시 고려할 사항
    - 비용
        + 대부분의 경우, 데이터 전송 양에 따라 요금을 내므로 캐싱할 콘텐츠를 선별하는게 주용
        + 적절한 만료시간 설정
            - 시의성이 중요한 콘텐츠의 경우
        + CDN 장애에 대한 대처방안

### 무상태 웹 계층 (stateless)
먼저 상태가 무엇인지 이해해야 하는데, 상태는 특정 사용자의 현재 정보나 컨텍스트를 의미한다  
예를 들면, 로그인 정보나 장바구니 내용, 현재 진행 중인 작업정보 등이 있다  

+ 상태유지 방식의 차이
    - 상태유지 웹서버 (Stateful)
        + 서버 메모리에 사용자 세선 정보를 저장
        + 해당 사용자는 계속 같은 서버로 요청해야 함
        + 서버가 죽으면 세선 정보도 날아감

        ```
        사용자A → 서버1 (사용자A 정보 저장)
        사용자A → 서버1 (같은 서버로 계속 가야 함)
        ```

    - 무상태 웹서버 (Stateless)
        + 서버는 사용자 정보를 저장하지 않음
        + 모든 요청이 독립적
        + 어떤 서버로 요청해도 동일한 응답 가능

        ```
        사용자A → 서버1
        사용자A → 서버2 (어떤 서버든 OK)
        사용자A → 서버3 (어떤 서버든 OK)
        ```
        + 장점
            - 확장성
                + 서버를 마음대로 늘리고 줄일 수 있음
                + 로드밸런서가 트래픽을 자유롭게 분산 가능
                    - 상태유지 웹서버의 경우, 로드밸런서가 고정 세션이라는 기능으로 클라이언트와 요청을 중계하는데, 이것은 로드밸런서에 부담을 준다
            - 가용성
                + 서버 한대가 죽어도 다른 서버가 처리
                + 무중단 배포가 쉬워짐
                    - 롤링 배포 (Rolling Deployment)로 배포를 진행하는데, 상태유지 웹서버의 경우 서버를 내리면 해당 서버에 저장된 세션 정보가 날아가고 사용자는 로그아웃된다
                    - 무상태 웹서버의 경우, 다른 서버로 사용자를 유도하여 처리하면 된다
            - 단순성
                + 서버 간 세션 동기화가 불필요
                + 서버 관리가 단순해짐
        + 단점
            - 공유 저장소가 추가되므로 네트워크에서 오버헤드가 생긴다
                + 하지만 확장성과 가용성에서 막대한 이득이 생기므로 네트워크 오버헤드를 감수할하다

### 데이터 센터
사용자는 DNS를 통해 가장 가까운 데이터 센터로 안내되어 요청을 처리한다  
이들 데이터 센터 중 하나에서 장애가 발생하면 모든 트래픽은 장애가 없는 가장 가까운 데이터 센터로 전송된다  
이러한 다중 데이터 센터 아키텍처를 만드려면 몇가지 기술적 난제를 해결해야 한다

+ 트래픽 우회
    - 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 확인해야 한다
+ 데이터 동기화
    - 데이터 센터마다 별도의 데이터베이스를 사용하는 상황이라면 전달받은 데이터 센터에서 찾는 데이터가 없을 수 있다
+ 테스트와 배포
    - 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 도와준다

### 메시지 큐
메시지 큐는 애플리케이션 간에 메시지를 주고받을 수 있도록 도와주는 중간 저장소, 우체통을 생각하면 편하다  
생산자/발신자가 메시지를 만들어 메시지 큐에 발생하면 소비자/구독자가 메시지를 받아 동작을 수행한다  

중요한 특징은 비동기 통신이라 메시지를 보내고 답을 기다리지 않고 바로 다른 일을 할 수 있다  

+ 장점
    - 응답 속도 개선 : 사용자는 즉시 응답을 받음
    - 시스템 분리 : 각 서비스가 독립적으로 동작
    - 부하 분산 : 메시지를 여러 컨슈머가 나눠서 처리할 수 있다
    - 안정성 : 일시적 장애가 발생해도 메시지는 큐에 보관되어 유실 방지
+ 실무에서 자주 사용하는 패턴
    - Point-to-Point (점대점)
        + 하나의 메시지는 한명의 구독자가 처리
        + 주문, 결제 처리
    - Publish-Subscribe (발행-구독)
        + 하나의 메시지를 여러 구독자가 받아서 처리
        + 주문 완료시 -> 재고, 배송, 알림 시스템 모두에게 전달
+ 주의할 점
    - 메시지 유실 방지
        + Producer : 메시지 발행 후 ACK 확인
        + Queue : 메시지를 디스크에 영구 저장
        + Consumer : 처리 완료 후에만 ACK 전송
    - 중복 처리 방지
        + 멱등성 보장 : 같은 메시지를 여러번 받아도 결과가 동일하도록
            - 주문번호로 중복체크 등
    - 순서보장
        + 메시지 순서가 보장되지 않는 경우가 있음

### 로그, 메트릭 그리고 자동화
+ 로그
    - 시스템에서 발생한 이벤트의 상세한 기록
    - 개별 이벤트의 상세 정보 포함
    - 텍스트 기반 (구조화, 비구조화)
    - 컨텍스트가 풍부함
        + 디버깅과 문제 해결에 유용
+ 메트릭
    - 시스템의 상태나 성능을 측정 가능한 숫자로 표현한 것

실무에서는 둘을 조합하여 사용한다  
메트릭으로 문제를 감지하고 로그로 원인을 분석하여 해결한다

### 데이터베이스의 규모 확장
저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다  
데이터베이스의 구모를 확장하는 데는 두가지 접근법이 있다

+ 수직적 확장
    - 스케일 업
    - 서버 하드웨어에는 한계가 있으므로 무한으로 증설할 수 없다
    - SPOF (Single Point of Failure)에 대한 위험성이 크다
    - 비용이 많이 든다 (고성능 하드웨어는 그만큼 비싸다)
+ 수평적 확장
    - 샤딩
    - 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 말한다
    - 모든 샤드는 같은 스키마를 사용하지만 샤드에 보관되는 데이터 사이에는 중복이 없다
    - 문제점
        + 데이터의 재 샤딩
            - 전체 데이터가 너무 많아져서 하나의 샤드로는 감당이 어려울 때
            - 샤드 간의 데이터 분포가 균등하지 못하여 하나의 샤드가 다른 샤드보다 많은 데이터를 저장할 때
        + 핫스팟키 문제
            - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸릴때
            - SNS를 예로 들면 유명인사가 하나의 샤드에 몰리게 되면 해당 샤드는 read 연산때문에 과부하가 걸린다
        + 조인과 비정규화
            - 하나의 데이터베이스를 여러 샤드로 쪼개버리면 여러 샤드에 걸친 데이터를 조인하기 어렵다
            - 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행되도록 한다